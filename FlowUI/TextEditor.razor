@using FlowCompiler
@using static FlowUI.BlockEditor;

@foreach(var block in _program.CodeBlocks)
{
    <BlockEditor Block="@block" BlockChanged="@OnBlockChanged"/>
}

<br />
<button onclick="@this.RunProgram">Run</button>
<br />

<div>Result: @EvaluatedResult</div>
<br />

@code {
    private IProgram _program = new Test(new List<Message>(), new List<Step>(), new List<Message>());

    [Inject]
    private ICompiler? Compiler { get; set; }
    [Inject]
    private IDebugger? Debugger { get; set; }

    [Parameter]
    public string EvaluatedResult { get; set; } = "Not run yet";

    protected override void OnInitialized()
    {
        _program = Compiler?.DefaultProgram() ?? _program;
    }

    [Parameter]
    public EventCallback ValueChanged { get; set; }

    private Task OnBlockChanged(IChangeData change)
    {
        if (Compiler is null) return Task.CompletedTask;

        _program = change switch
        {
            LineAddedData added => Compiler.ProgramChanged(
                new LineAdded(_program, added)),
            LineChangedData changed => Compiler.ProgramChanged(
                new LineChanged(_program, changed)),
            LineRemovedData removed => Compiler.ProgramChanged(
                new LineRemoved(_program, removed)),
            _ => _program
        };

        return Task.CompletedTask;
    }

    private void RunProgram()
    {
        var dllPath = @"Content\test.dll";

        if(Compiler is null || Debugger is null || _program is not Test test) return;

        var IL = test.Code.
        SelectMany(c => c.Lines).
        Select(l => l.ParsedLine).
        OfType<EmitLine>().
        Select(l => l.IL);

        Compiler.BuildDll(dllPath, IL);
        EvaluatedResult = Debugger.LaunchApplication(dllPath).ToString() ?? "Error";

        ValueChanged.InvokeAsync();
    }

}
