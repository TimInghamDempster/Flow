@using FlowCompiler

<div tabindex="0" onkeypress="@TypingHappened" onkeydown="@SpecialKey" >
    @foreach(var linePart in CodeLine)
    {
        @(linePart switch
        {
            LinePart lp => (@<span style="color:@lp.Colour">@lp.Text</span>),
            Caret => (@<span style="opacity:@CursorOpacity">|</span>),
            _ => (@<span/>)
        })
    }
</div>
<br/>
<button onclick="@this.RunProgram">Run</button>
<br/>

<div>Result: @EvaluatedResult</div>
<br/>
<div>@Error</div>

@code {
    private ParsedLine? _line;

    private interface ILinePart{};
    private record LinePart(string Text, string Colour = "black") : ILinePart;
    private record Caret() : ILinePart;

    [Inject]
    private ICompiler? Compiler{ get; set; }
    [Inject] 
    private IDebugger? Debugger{ get; set; }

    private Caret[] _caret = new[] { new Caret()};
    private IEnumerable<ILinePart> CodeLine =>
        _line?.Tokens.Select<Token,ILinePart>(t =>
            t switch
            {
                Keyword => new LinePart(t.Value + " ", "cornflowerblue"),
                Name => new LinePart(t.Value + " ", "gold"),
                _ => new LinePart(t.Value)
            }
        ).Concat(_caret) ??
        _caret;

    [Parameter] 
    public string EvaluatedResult { get; set; } = "Not run yet";

    private string _code = "";

    public string Error => string.Join("\n", _line?.Tokens.OfType<ErrorToken>().Select(e => e.Error) ?? Enumerable.Empty<string>());

    [Parameter] 
    public EventCallback ValueChanged {get;set;}

    private void LineChanged(ChangeEventArgs e)
    {
        _line = Compiler?.CompileLine(e.Value?.ToString() ?? "");

        if (_line is GoodLine goodLine)
        {
            ValueChanged.InvokeAsync();
        }
    }

    private void RunProgram()
    {
        // Can't actually happen, but injection and nullable
        // references don't play nicely
        if (_line is null) return;

        var dllPath = @"Content\test.dll";
        Compiler?.BuildDll(dllPath, _line);
        EvaluatedResult = Debugger?.LaunchApplication(dllPath).ToString() ?? "Error";

        ValueChanged.InvokeAsync();
    }

    private System.Timers.Timer _timer = new ();
    private int CursorOpacity { get; set; }

    private void StartCursorBlink()
    {
        _timer = new System.Timers.Timer();
        _timer.Interval = 500;
        _timer.Elapsed += OnBlinkCursor;
        _timer.AutoReset = true;
        _timer.Enabled = true;
    }
    private void OnBlinkCursor(Object? source, System.Timers.ElapsedEventArgs e)
    {
        CursorOpacity = CursorOpacity switch
        {
            100 => 0,
            0 => 100,
            _ => 0
        };
        InvokeAsync(StateHasChanged);
    }
    protected override Task OnInitializedAsync()
    {
        StartCursorBlink();
        return base.OnInitializedAsync();
    }

    private void TypingHappened(KeyboardEventArgs e)
    {
        _code += e.Key;
        _line = Compiler?.CompileLine(_code);
    }

    private void SpecialKey(KeyboardEventArgs e)
    {
        if(e.Key == "Backspace")
        {
            _code = _code.Remove(_code.Length - 1);
            _line = Compiler?.CompileLine(_code);
        }
    }
}
