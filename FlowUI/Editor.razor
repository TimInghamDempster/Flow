@using FlowCompiler

<div>
    @foreach(var linePart in CodeLine)
    {
        <span style="color:@linePart.Colour">@linePart.Text</span>
    }
</div>
<button onclick="@this.RunProgram">Run</button>
<br/>

<div>Result: @EvaluatedResult</div>
<br/>
<div>@Error</div>

@code {
    private ParsedLine? _line;

    private record LinePart(string Text, string Colour = "black");

    [Inject]
    private ICompiler? Compiler{ get; set; }
    [Inject] 
    private IDebugger? Debugger{ get; set; }

    private IEnumerable<LinePart> CodeLine
    {
        get
        {
            yield return new LinePart("Test ", "blue");
            yield return new LinePart("Part ");
            yield return new LinePart("3");
        }
    }
    /*(_line is GoodLine goodLine) ?
        goodLine.Tokens.Select(t => new LinePart(t.Value)) :
        Enumerable.Empty<LinePart>();*/

    [Parameter] 
    public string EvaluatedResult { get; set; } = "Not run yet";

    public string Error => string.Join("\n", _line?.Tokens.OfType<ErrorToken>().Select(e => e.Error) ?? Enumerable.Empty<string>());

    [Parameter] 
    public EventCallback ValueChanged {get;set;}

    private void LineChanged(ChangeEventArgs e)
    {
        _line = Compiler?.CompileLine(e.Value?.ToString() ?? "");

        if (_line is GoodLine goodLine)
        {
            ValueChanged.InvokeAsync();
        }
    }

    private void RunProgram()
    {
        // Can't actually happen, but injection and nullable
        // references don't play nicely
        if (_line is null) return;

        var dllPath = @"Content\test.dll";
        Compiler?.BuildDll(dllPath, _line);
        EvaluatedResult = Debugger?.LaunchApplication(dllPath).ToString() ?? "Error";

        ValueChanged.InvokeAsync();
    }
}
